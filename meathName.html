<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <script>
//         事件名(要统一的名字)
// 不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：

// this.$emit('myEvent')
// 则监听这个名字的 kebab-case 版本是不会有任何效果的：

// <!-- 没有效果 -->
// <my-component v-on:my-event="doSomething"></my-component>
// 不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。

// 因此，我们推荐你始终使用 kebab-case 的事件名。
//自定义组件的双向绑定自定义组件的 v-model


// 一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用来避免这样的冲突：

// Vue.component('base-checkbox', {
//   model: {
//     prop: 'checked',
//     event: 'change'
//   },
//   props: {
//     checked: Boolean
//   },
//   template: `
//     <input
//       type="checkbox"
//       v-bind:checked="checked"
//       v-on:change="$emit('change', $event.target.checked)"
//     >
//   `
// })
// 现在在这个组件上使用 v-model 的时候：

// <base-checkbox v-model="lovingVue"></base-checkbox>
// 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 <base-checkbox> 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。
    </script>
    
</body>
</html>