<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>
    <div id="app">
        <!-- 为什么在传入值得时候前面都加上冒号是告诉，vue这是javascript表达式而不是一个字符串 -->

        <!-- HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。
            这意味着当你使用 DOM 中的模板时，
            camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名： -->
        <test-component :title='title'></test-component>
        <!-- 动态赋予一个变量的值 -->

        <!-- 传递静态或动态 Prop -->

        <!-- <blog-post v-bind:title="post.title"></blog-post> -->

        <!-- 动态赋予一个复杂表达式的值 -->
        <!-- <blog-post
        v-bind:title="post.title + ' by ' + post.author.name"
        ></blog-post> -->

        <!-- 传入一个数字 -->
        <!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->
        <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->
        <!-- <blog-post v-bind:likes="42"></blog-post> -->

        <!-- 用一个变量进行动态赋值。-->
        <!-- <blog-post v-bind:likes="post.likes"></blog-post> -->

        <!-- 传入一个布尔值 -->
        <!-- 直接绑定的再不传任何值的时候，那么就是默认是true -->
        <!-- 包含该 prop 没有值的情况在内，都意味着 `true`。-->
        <!-- <blog-post is-published></blog-post> -->

        <!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->
        <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->
        <!-- <blog-post v-bind:is-published="false"></blog-post> -->

        <!-- 用一个变量进行动态赋值。-->
        <!-- <blog-post v-bind:is-published="post.isPublished"></blog-post> -->

        <!-- 传入一个数组 -->
        <!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->
        <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->
        <!-- <blog-post v-bind:comment-ids="[234, 266, 273]"></blog-post> -->
        
        <!-- 用一个变量进行动态赋值。-->
        <!-- <blog-post v-bind:comment-ids="post.commentIds"></blog-post> -->

        <!-- 传入一个对象的所有 property -->
        <!-- 如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：

        post: {
        id: 1,
        title: 'My Journey with Vue' -->
        }
        <!-- 下面的模板：

        <blog-post v-bind="post"></blog-post>
        等价于：

        <blog-post
        v-bind:id="post.id"
        v-bind:title="post.title"
        ></blog-post> -->

        <!-- 单向数据流 -->
<!-- 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：
    父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。
额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，
Vue 会在浏览器的控制台中发出警告。这里有两种常见的试图变更一个 prop 的情形： -->

<!-- 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。
    在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：

props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
} -->

<!-- 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：

props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
} -->

<!-- Prop 验证 -->
<!-- 我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。

为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如： -->
<!-- Vue.component('my-component', {
    props: {
      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
      propA: Number,
      // 多个可能的类型
      propB: [String, Number],
      // 必填的字符串
      propC: {
        type: String,
        required: true
      },
      // 带有默认值的数字
      propD: {
        type: Number,
        default: 100
      },
      // 带有默认值的对象
      propE: {
        type: Object,
        // 对象或数组默认值必须从一个工厂函数获取
        default: function () {
          return { message: 'hello' }
        }
      },
      // 自定义验证函数
      propF: {
        validator: function (value) {
          // 这个值必须匹配下列字符串中的一个
          return ['success', 'warning', 'danger'].indexOf(value) !== -1
        }
      }
    }
  }) -->
  
  <!-- 非 Prop 的 Attribute -->
<!-- 一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。

因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。

例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <bootstrap-date-input> 组件，这个插件需要在其 <input> 上用到一个 data-date-picker attribute。我们可以将这个 attribute 添加到你的组件实例上：

<bootstrap-date-input data-date-picker="activated"></bootstrap-date-input>
然后这个 data-date-picker="activated" attribute 就会自动添加到 <bootstrap-date-input> 的根元素上。 -->

    </div>
    <script>
        Vue.component("test-component",{
            props:["title"],
            template:"<h1>{{ title }}<h1>"
        })
        var vm = new Vue({
            el:"#app",
            data () {
                return {
                    title:'大宝贝'
                }
            }
        })
    </script>
</body>
</html>